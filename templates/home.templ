package templates

import (
	"fmt"
	"strconv"
	"github.com/marianozunino/drop/internal/config"
)

templ HomePage(config config.Config) {
	<!DOCTYPE html>
	<html lang="en">
		<head>
			<meta charset="UTF-8"/>
			<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
			<title>Drop</title>
			<style>
				pre {
					white-space: pre;
					font-family: monospace;
					line-height: 1.2;
					overflow-x: auto;
				}
			</style>
		</head>
		<body>
			<h1>Drop</h1>
			<p>Temporary file hoster, inspired by <a href="https://0x0.st/">0x0.st</a> .</p>
			<p><small>A personal service for quick file sharing.</small></p>
			<p><strong>Note:</strong> While inspired by 0x0.st, this implementation is not intended to provide full API compatibility with their service.</p>
			<div>
				min_age = { strconv.Itoa(config.MinAge) } days
				<br/>
				max_age = { strconv.Itoa(config.MaxAge) } days
				<br/>
				max_size = { fmt.Sprintf("%.1f", config.MaxSize) } MiB
				<br/>
				retention = min_age + (min_age - max_age) * pow((file_size / max_size - 1), 3)
			</div>
			<pre>
				@RetentionGraph(config)
			</pre>
			<details id="uploading">
				<summary>Uploading files</summary>
				<pre>
					@ValidFields(config)
				</pre>
				<details>
					<summary>cURL examples</summary>
					<pre>
						@Examples(config)
					</pre>
				</details>
				<p>
					It is possible to append a custom file name to any URL:
					<br/>
					<code>{ config.BaseURL }aaa.jpg/image.jpeg</code>
				</p>
				<p>File URLs are valid for at least { strconv.Itoa(config.MinAge) } days and up to { strconv.Itoa(config.MaxAge) } days (see above).</p>
				<p>Expired files won't be removed immediately but within the next { strconv.Itoa(config.CheckInterval) } minutes.</p>
				<p>Maximum file size: { fmt.Sprintf("%.1f", config.MaxSize) } MiB (see above).</p>
				<p>For large files (>10MB), consider using the chunked upload feature for better reliability and resume capability.</p>
			</details>
			<details id="client-download">
				<summary>Download Client</summary>
				<p>Download the Drop command-line client for easy file uploads and management:</p>
				<p><strong>One-line install:</strong></p>
				<pre>curl -L { DownloadURL(config) } | sh</pre>
				<p><strong>Quick Start:</strong></p>
				<pre>
@templ.Raw(`# Download and install (auto-detect platform)
curl -L ` + DownloadURL(config) + ` | sh

# Upload a file
./drop upload file.txt

# Upload with options
./drop upload --secret --expires 24 file.txt

# Upload large file (auto-chunked)
./drop upload large-file.zip

# Delete a file
./drop delete abc123 --token your-token`)
				</pre>
				<p><strong>Features:</strong></p>
				<ul>
					<li>Simple command-line interface</li>
					<li>Automatic chunked upload for large files</li>
					<li>Progress tracking and resume capability</li>
					<li>MD5 verification for file integrity</li>
					<li>File management (delete, set expiration)</li>
					<li>Configuration management</li>
				</ul>
			</details>
			<details id="chunked-uploading">
				<summary>Chunked Upload (Large Files)</summary>
				<p>For large files, use the chunked upload feature which provides:</p>
				<ul>
					<li>Resume capability - Continue interrupted uploads</li>
					<li>Progress tracking - Monitor upload progress</li>
					<li>Memory efficient - Only 4MB chunks in memory</li>
					<li>Network resilient - Survives connection drops</li>
					<li>Large file support - Handles files up to { fmt.Sprintf("%.1f", config.MaxSize) } MiB</li>
				</ul>
				<p><strong>🎯 Try the <a href="/chunked" style="color: #667eea; text-decoration: none; font-weight: 600;">Drag & Drop Interface</a> for easy chunked uploads!</strong></p>
				<pre>
					@ChunkedUploadFields(config)
				</pre>
				<details>
					<summary>cURL examples</summary>
					<pre>
						@ChunkedUploadExamples(config)
					</pre>
				</details>
				<p>Upload sessions expire after 24 hours - Complete your upload within this time.</p>
				<p>If interrupted, you can resume by uploading only the missing chunks.</p>
			</details>
			<details id="api-responses">
				<summary>API Response Format</summary>
				<p>The service returns different response formats depending on the request:</p>
				
				<h4>Regular Upload Response (JSON)</h4>
				<p>When uploading with <code>Accept: application/json</code> header:</p>
				<pre>
@templ.Raw(`{
  "url": "http://localhost:3000/abc123.txt",
  "size": 1024,
  "token": "management_token_here",
  "md5": "d41d8cd98f00b204e9800998ecf8427e",
  "expires_at": "2024-12-31T23:59:59Z",
  "expires_in_days": 30
}`)
				</pre>
				
				<h4>Chunked Upload Completion Response (JSON)</h4>
				<p>When chunked upload completes successfully:</p>
				<pre>
@templ.Raw(`{
  "message": "Upload completed",
  "progress": 100,
  "file_url": "http://localhost:3000/abc123.txt",
  "md5": "d41d8cd98f00b204e9800998ecf8427e",
  "token": "management_token_here",
  "expires_at": "2024-12-31T23:59:59Z",
  "expires_in_days": 30
}`)
				</pre>
				
				<h4>Response Fields</h4>
				<pre>
@templ.Raw(`┌─────────────────┬────────────┬────────────────────────────────────────────┐
│ field           │ type       │ description                                │
╞═════════════════╪════════════╪════════════════════════════════════════════╡
│ url             │ string     │ Direct file access URL                     │
├─────────────────┼────────────┼────────────────────────────────────────────┤
│ file_url        │ string     │ Direct file access URL (chunked uploads)   │
├─────────────────┼────────────┼────────────────────────────────────────────┤
│ size            │ integer    │ File size in bytes                         │
├─────────────────┼────────────┼────────────────────────────────────────────┤
│ token           │ string     │ Management token for file operations       │
├─────────────────┼────────────┼────────────────────────────────────────────┤
│ md5             │ string     │ MD5 hash of the uploaded file              │
├─────────────────┼────────────┼────────────────────────────────────────────┤
│ expires_at      │ string     │ Expiration date (ISO format)               │
├─────────────────┼────────────┼────────────────────────────────────────────┤
│ expires_in_days │ integer    │ Days until expiration                      │
├─────────────────┼────────────┼────────────────────────────────────────────┤
│ message         │ string     │ Status message (chunked uploads)           │
├─────────────────┼────────────┼────────────────────────────────────────────┤
│ progress        │ integer    │ Upload progress percentage (0-100)         │
└─────────────────┴────────────┴────────────────────────────────────────────┘`)
				</pre>
				
				<h4>MD5 Hash Benefits</h4>
				<ul>
					<li><strong>File Integrity</strong>: Verify uploaded files haven't been corrupted</li>
					<li><strong>Duplicate Detection</strong>: Compare MD5 hashes to identify duplicate files</li>
					<li><strong>Data Validation</strong>: Ensure file integrity during transfer</li>
					<li><strong>Audit Trail</strong>: Hash can be used for file tracking and verification</li>
				</ul>
				
				<p><strong>Note:</strong> MD5 hash is calculated automatically after upload completion. If calculation fails, the field will be an empty string.</p>
			</details>
			<details id="managing">
				<summary>Managing your files</summary>
				<pre>
					@FileManagement()
				</pre>
				<details>
					<summary>cURL examples</summary>
					<p>Delete a file immediately:</p>
					<pre>curl -X POST -F'token=token_here' -F'delete=' { config.BaseURL }abc.txt</pre>
					<p>Change the expiration date (see above):</p>
					<pre>curl -X POST -F'token=token_here' -F'expires=3' { config.BaseURL }abc.txt</pre>
				</details>
			</details>
			<details>
				<summary>Terms of Service</summary>
				<p>This service is NOT a platform for:</p>
				<ul>
					<li>piracy</li>
					<li>pornography and gore</li>
					<li>extremist material of any kind</li>
					<li>terrorist content</li>
					<li>malware / botnet C&C</li>
					<li>anything related to crypto currencies</li>
					<li>backups</li>
					<li>CI build artifacts</li>
					<li>other automated mass uploads</li>
					<li>doxxing, database dumps containing personal information</li>
					<li>anything illegal</li>
				</ul>
				<p>
					Uploads found to be in violation of these rules will be removed,
					and the originating IP address may be blocked from further uploads.
				</p>
			</details>
			<details>
				<summary>Privacy Policy</summary>
				<p>For the purpose of moderation, the following is stored with each uploaded file:</p>
				<ul>
					<li>IP address</li>
					<li>User agent string</li>
				</ul>
				<p>This site generally does not log requests, but may enable logging if necessary for purposes such as threat mitigation.</p>
				<p>No data is shared with third parties.</p>
			</details>
			<hr/>
			<p>Personal instance inspired by <a href="https://0x0.st/">0x0.st</a>.</p>
			<p>Hosted on mz.uy for personal use.</p>
		</body>
	</html>
}

templ RetentionGraph(config config.Config) {
	@templ.Raw(`
   days
   ` + strconv.Itoa(config.MaxAge) + `  |  \
       |   \
       |    \
       |     \
       |      \
       |       \
       |        ..
       |          \
   ` + strconv.Itoa((config.MinAge+config.MaxAge)/2) + `  | ----------..-------------------------------------------
       |             ..
       |               \
       |                ..
       |                  ...
       |                     ..
       |                       ...
       |                          ....
       |                              ......
    ` + strconv.Itoa(config.MinAge) + `  |                                    ....................
         0                      ` + fmt.Sprintf("%.1f", config.MaxSize/2) + `                      ` + fmt.Sprintf("%.1f", config.MaxSize) + `
                                                             MiB
    `)
}

templ ValidFields(config config.Config) {
	@templ.Raw(`
Send HTTP POST requests to ` + config.BaseURL + ` with data encoded as multipart/form-data

Valid fields are:
  ┌─────────┬────────────┬──────────────────────────────────────────────────┐
  │ field   │ content    │ remarks                                          │
  ╞═════════╪════════════╪══════════════════════════════════════════════════╡
  │ file    │ data       │                                                  │
  ├─────────┼────────────┼──────────────────────────────────────────────────┤
  │ url     │ remote URL │ Mutually exclusive with "file".                  │
  │         │            │ Remote site must return Content-Length header.   │
  ├─────────┼────────────┼──────────────────────────────────────────────────┤
  │ secret  │ (ignored)  │ If present, a longer, hard-to-guess URL          │
  │         │            │ will be generated.                               │
  ├─────────┼────────────┼──────────────────────────────────────────────────┤
  │ one_time│ (ignored)  │ If present, file will be deleted after first     │
  │         │            │ download or view.                                │
  │         │            │                                                  │
  │         │            │ When sharing one time links some bots may        │
  │         │            │ consume the link immediately.                    │
  ├─────────┼────────────┼──────────────────────────────────────────────────┤
  │ expires │ time       │ Sets file expiration time. Accepts:              │
  │         │ format     │ - Hours as integer (e.g., 24)                    │
  │         │            │ - Milliseconds since epoch (e.g., 1681996320000) │
  │         │            │ - RFC3339 (e.g., 2006-01-02T15:04:05Z07:00)      │
  │         │            │ - ISO date (e.g., 2006-01-02)                    │
  │         │            │ - ISO datetime (e.g., 2006-01-02T15:04:05)       │
  │         │            │ - SQL datetime (e.g., 2006-01-02 15:04:05)       │
  └─────────┴────────────┴──────────────────────────────────────────────────┘

`)
}

templ FileManagement() {
	@templ.Raw(`
	Whenever a file that does not already exist or has expired is uploaded,
	the HTTP response header includes an X-Token field. You can use this
	to perform management operations on the file by sending POST requests
	to the file URL.
	When using cURL, you can add the -i option to view the response header.
	Valid fields are:
	┌─────────┬────────────┬──────────────────────────────────────────────────┐
	│ field   │ content    │ remarks                                          │
	╞═════════╪════════════╪══════════════════════════════════════════════════╡
	│ token   │ management │ Returned after upload in X-Token HTTP header     │
	│         │ token      │ field. Required.                                 │
	├─────────┼────────────┼──────────────────────────────────────────────────┤
	│ delete  │ (ignored)  │ Removes the file.                                │
	├─────────┼────────────┼──────────────────────────────────────────────────┤
	│ expires │ time       │ Sets file expiration time. Accepts:              │
	│         │ format     │ - Hours as integer (e.g., 24)                    │
	│         │            │ - Milliseconds since epoch (e.g., 1681996320000) │
	│         │            │ - RFC3339 (e.g., 2006-01-02T15:04:05Z07:00)      │
	│         │            │ - ISO date (e.g., 2006-01-02)                    │
	│         │            │ - ISO datetime (e.g., 2006-01-02T15:04:05)       │
	│         │            │ - SQL datetime (e.g., 2006-01-02 15:04:05)       │
	└─────────┴────────────┴──────────────────────────────────────────────────┘
`)
}

templ Examples(config config.Config) {
	@templ.Raw(`
    Uploading a file:
        curl -F'file=@yourfile.png' ` + config.BaseURL + `

    Copy a file from a remote URL:
        curl -F'url=http://example.com/image.jpg' ` + config.BaseURL + `

    Same, but with hard-to-guess URLs:
        curl -F'file=@yourfile.png' -Fsecret= ` + config.BaseURL + `
        curl -F'url=http://example.com/image.jpg' -Fsecret= ` + config.BaseURL + `

    Create a one-time download link (file is deleted after first download):
        curl -F'file=@yourfile.png' -Fone_time= ` + config.BaseURL + `

    Setting retention time in hours:
        curl -F'file=@yourfile.png' -Fexpires=24 ` + config.BaseURL + `

    Setting expiration date with milliseconds since UNIX epoch:
        curl -F'file=@yourfile.png' -Fexpires=1681996320000 ` + config.BaseURL + `

    Setting expiration date with RFC3339 format:
        curl -F'file=@yourfile.png' -Fexpires=2023-04-20T10:15:30Z ` + config.BaseURL + `

    Setting expiration date with ISO date format:
        curl -F'file=@yourfile.png' -Fexpires=2023-04-20 ` + config.BaseURL + `

    Setting expiration date with ISO datetime format:
        curl -F'file=@yourfile.png' -Fexpires=2023-04-20T10:15:30 ` + config.BaseURL + `

    Setting expiration date with SQL datetime format:
        curl -F'file=@yourfile.png' -Fexpires="2023-04-20 10:15:30" ` + config.BaseURL + `

    Combining options (one-time view with expiration and secret URL):
        curl -F'file=@yourfile.png' -Fone_time= -Fsecret= -Fexpires=24 ` + config.BaseURL + `
	`)
}

templ ChunkedUploadFields(config config.Config) {
	@templ.Raw(`
Chunked upload process:

1. INITIALIZE UPLOAD:
   POST ` + config.BaseURL + `upload/init
   ┌─────────────┬────────────┬──────────────────────────────────────────────────┐
   │ field       │ content    │ remarks                                          │
   ╞═════════════╪════════════╪══════════════════════════════════════════════════╡
   │ filename    │ file name  │ Original filename                                │
   ├─────────────┼────────────┼──────────────────────────────────────────────────┤
   │ size        │ bytes      │ Total file size in bytes                         │
   ├─────────────┼────────────┼──────────────────────────────────────────────────┤
   │ chunk_size  │ bytes      │ Optional: Custom chunk size (default: 4MB)       │
   └─────────────┴────────────┴──────────────────────────────────────────────────┘

2. UPLOAD CHUNKS:
   POST ` + config.BaseURL + `upload/chunk/{upload_id}/{chunk}
   ┌─────────────┬────────────┬──────────────────────────────────────────────────┐
   │ field       │ content    │ remarks                                          │
   ╞═════════════╪════════════╪══════════════════════════════════════════════════╡
   │ chunk       │ file data  │ Chunk data (multipart/form-data)                 │
   └─────────────┴────────────┴──────────────────────────────────────────────────┘

3. CHECK STATUS:
   GET ` + config.BaseURL + `upload/status/{upload_id}
   Returns: {
     "upload_id": "abc123",
     "filename": "large-file.zip",
     "total_size": 104857600,
     "chunk_size": 4194304,
     "total_chunks": 25,
     "uploaded_chunks": [0,1,2,3,4],
     "progress": 20,
     "created_at": "2024-01-01T10:00:00Z",
     "expires_at": "2024-01-02T10:00:00Z"
   }

4. FINALIZE:
   When all chunks are uploaded, the file is automatically finalized
   and available at the returned URL.

Response format:
┌─────────────────┬────────────┬───────────────────────────────────────┐
│ field           │ content    │ remarks                               │
╞═════════════════╪════════════╪═══════════════════════════════════════╡
│ upload_id       │ string     │ Unique upload session ID              │
├─────────────────┼────────────┼───────────────────────────────────────┤
│ chunk_size      │ bytes      │ Chunk size used for this upload       │
├─────────────────┼────────────┼───────────────────────────────────────┤
│ total_chunks    │ integer    │ Total number of chunks needed         │
├─────────────────┼────────────┼───────────────────────────────────────┤
│ uploaded_chunks │ array      │ Array of uploaded chunk indices       │
└─────────────────┴────────────┴───────────────────────────────────────┘
`)
}

templ ChunkedUploadExamples(config config.Config) {
	@templ.Raw(`
    Initialize chunked upload for a 100MB file:
        curl -X POST ` + config.BaseURL + `upload/init \
            -F "filename=large-video.mp4" \
            -F "size=104857600" \
            -F "chunk_size=4194304"

    Upload chunk 0 (first chunk):
        curl -X POST ` + config.BaseURL + `upload/chunk/abc123/0 \
            -F "chunk=@chunk_0.bin"

    Upload chunk 1 (second chunk):
        curl -X POST ` + config.BaseURL + `upload/chunk/abc123/1 \
            -F "chunk=@chunk_1.bin"

    Check upload progress:
        curl ` + config.BaseURL + `upload/status/abc123

    Resume interrupted upload (upload only missing chunks):
        # Check which chunks are missing
        curl ` + config.BaseURL + `upload/status/abc123
        
        # Upload only the missing chunks
        curl -X POST ` + config.BaseURL + `upload/chunk/abc123/15 \
            -F "chunk=@chunk_15.bin"

    Using custom chunk size (2MB instead of 4MB):
        curl -X POST ` + config.BaseURL + `upload/init \
            -F "filename=huge-file.zip" \
            -F "size=209715200" \
            -F "chunk_size=2097152"
`)
}

func DownloadURL(config config.Config) string {
	return config.BaseURL + "download"
}
